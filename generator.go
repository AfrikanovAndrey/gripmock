package main

import (
	"bytes"
	"go/format"
	"io"
	"os"
	"strings"
	"text/template"
)

type generatorParam struct {
	Services  []serviceTemplate
	GrpcAddr  string
	AdminPort string
	PbPath    string
}

type serviceTemplate struct {
	Name    string
	Methods []methodTemplate
}

type methodTemplate struct {
	Name        string
	ServiceName string
	MethodType  string
	Input       string
	Output      string
}

const (
	methodTypeStandard      = "standard"
	methodTypeServerStream  = "server-stream"
	methodTypeClientStream  = "client-stream"
	methodTypeBidirectional = "bidirectional"
)

type Options struct {
	writer    io.Writer
	grpcAddr  string
	adminPort string
	pbPath    string
}

func GenerateServer(services []Service, opt *Options) error {
	param := generatorParam{
		Services:  convertTemplateService(services),
		GrpcAddr:  opt.grpcAddr,
		AdminPort: opt.adminPort,
		PbPath:    opt.pbPath,
	}

	if opt == nil {
		opt = &Options{}
	}

	if opt.writer == nil {
		opt.writer = os.Stdout
	}

	tmpl := template.New("server.tmpl")
	tmpl, err := tmpl.Parse(SERVER_TEMPLATE)
	if err != nil {
		return err
	}

	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, param)
	if err != nil {
		return err
	}

	byt, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	_, err = opt.writer.Write(byt)
	return err
}

// change the structure also translate method type
func convertTemplateService(services []Service) []serviceTemplate {
	svcTmp := make([]serviceTemplate, len(services))
	for i, svc := range services {
		svcTmp[i].Name = svc.Name
		methods := make([]methodTemplate, len(svc.Methods))
		for j, method := range svc.Methods {
			tipe := methodTypeStandard
			if method.StreamInput && !method.StreamOutput {
				tipe = methodTypeServerStream
			} else if !method.StreamInput && method.StreamOutput {
				tipe = methodTypeClientStream
			} else if method.StreamInput && method.StreamOutput {
				tipe = methodTypeBidirectional
			}

			methods[j] = methodTemplate{
				Name:        strings.Title(method.Name),
				ServiceName: svc.Name,
				Input:       method.Input,
				Output:      method.Output,
				MethodType:  tipe,
			}
		}
		svcTmp[i].Methods = methods
	}
	return svcTmp
}

const SERVER_TEMPLATE = `// DO NOT EDIT. This file is autogenerated by GripMock
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"

	"github.com/mitchellh/mapstructure"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

const (
	TCP_ADDRESS  = "{{.GrpcAddr}}"
	HTTP_PORT = ":{{.AdminPort}}"
)

{{ range .Services }}
{{ template "services" . }}
{{ end }}

func main() {
	lis, err := net.Listen("tcp", TCP_ADDRESS)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	s := grpc.NewServer()
	{{ range .Services }}
	{{ template "register_services" . }}
	{{ end }}

	reflection.Register(s)
	fmt.Println("Serving gRPC on tcp://" + TCP_ADDRESS)
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

{{ template "find_stub" }}

{{ define "services" }}
type {{.Name}} struct{}

{{ template "methods" .}}
{{ end }}

{{ define "methods" }}
{{ range .Methods}}
	{{ if eq .MethodType "standard"}}
		{{ template "standard_method" .}}
	{{ end }}
{{end}}
{{end}}

{{ define "standard_method" }}
func (s *{{.ServiceName}}) {{.Name}}(ctx context.Context, in *{{.Input}}) (*{{.Output}},error){
	out := &{{.Output}}{}
	err := findStub("{{.ServiceName}}", "{{.Name}}", in, out)
	return out, err
}
{{ end }}

{{ define "register_services" }}
	Register{{.Name}}Server(s, &{{.Name}}{})
{{ end }}

{{ define "find_stub" }}
type payload struct {
	Service string      ` + "`json:\"service\"`" + `
	Method  string      ` + "`json:\"method\"`" + `
	Data    interface{} ` + "`json:\"data\"`" + `
}

type response struct {
	Data  interface{} ` + "`json:\"data\"`" + `
	Error string      ` + "`json:\"error\"`" + `
}

func findStub(service, method string, in, out interface{}) error {
	url := fmt.Sprintf("http://localhost%s/find", HTTP_PORT)
	pyl := payload{
		Service: service,
		Method:  method,
		Data:    in,
	}
	byt, err := json.Marshal(pyl)
	if err != nil {
		return err
	}
	reader := bytes.NewReader(byt)
	resp, err := http.DefaultClient.Post(url, "application/json", reader)
	if err != nil {
		return err
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf(string(body))
	}

	respRPC := new(response)
	err = json.NewDecoder(resp.Body).Decode(respRPC)
	if err != nil {
		return err
	}

	if respRPC.Error != "" {
		return fmt.Errorf(respRPC.Error)
	}

	return mapstructure.Decode(respRPC.Data, out)
}
{{ end }}`
